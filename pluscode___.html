<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Plus Code Grid Viewer</title>
  
  <link rel="stylesheet" href="css/lib/ol_6.5.0.css">
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { height: 100%; width: 100%; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif; }
    #app { height: 100%; width: 100%; position: relative; }
    #map { height: 100%; width: 100%; }
    
    .info-panel {
      position: absolute; top: 10px; left: 10px;
      background: rgba(0, 0, 0, 0.85); color: white;
      padding: 12px 16px; border-radius: 8px;
      font-family: 'Courier New', monospace; font-size: 13px;
      line-height: 1.8; z-index: 1000; pointer-events: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    .info-panel div { margin: 2px 0; }
    .info-label { color: #aaa; display: inline-block; width: 100px; }
    .info-value { color: #0ff; font-weight: bold; }
    
    .toggle-button {
      position: absolute; top: 10px; right: 10px;
      background: rgba(255, 255, 255, 0.95); border: 2px solid #333;
      border-radius: 6px; padding: 10px 16px; font-size: 14px;
      font-weight: bold; color: #333; cursor: pointer;
      z-index: 1000; box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      transition: all 0.3s ease; pointer-events: auto;
    }
    .toggle-button:hover { background: rgba(255, 255, 255, 1); transform: translateY(-1px); }
    .toggle-button.active { background: rgba(40, 167, 69, 0.95); color: white; border-color: #28a745; }
  </style>
</head>
<body>
  <div id="app">
    <div id="map"></div>
    
    <div class="info-panel" v-show="gridVisible">
      <div><span class="info-label">Zoom Level:</span><span class="info-value">{{ zoom }}</span></div>
      <div><span class="info-label">Grid Size:</span><span class="info-value">{{ gridRows }}x{{ gridCols }}</span></div>
      <div><span class="info-label">Cell Size:</span><span class="info-value">{{ cellSizeLon.toFixed(4) }}° x {{ cellSizeLat.toFixed(4) }}°</span></div>
      <div><span class="info-label">Total Cells:</span><span class="info-value">{{ gridRows * gridCols }}</span></div>
    </div>

    <button class="toggle-button" :class="{ active: gridVisible }" @click="toggleGrid">
      {{ gridVisible ? '✓ Grid ON' : '✗ Grid OFF' }}
    </button>
  </div>

  <script src="js/lib/vue3.js"></script>
  <script src="js/lib/ol_6.5.0.js"></script>
  <script src="js/lib/openlocationcode.min.js"></script>

  <script>
    const { createApp, ref, onMounted, onUnmounted } = Vue;

    createApp({
      setup() {
        const zoom = ref(12.0);
        const gridVisible = ref(true);
        const gridRows = ref(9);
        const gridCols = ref(9);
        const cellSizeLon = ref(0);
        const cellSizeLat = ref(0);
        
        let map = null;
        let vectorSource = null;
        let vectorLayer = null;
        let updateTimeout = null;

        const cellStyle = new ol.style.Style({
          stroke: new ol.style.Stroke({ color: 'rgba(255, 50, 50, 0.8)', width: 2 }),
          fill: new ol.style.Fill({ color: 'rgba(255, 0, 0, 0.08)' })
        });

        const toggleGrid = () => {
          gridVisible.value = !gridVisible.value;
          if (vectorLayer) {
            vectorLayer.setVisible(gridVisible.value);
            if (gridVisible.value) updateGrid();
          }
        };

        /**
         * FIXED: Generate exactly N x N grid filling entire screen
         */
        const updateGrid = () => {
          if (!map || !vectorSource || !gridVisible.value) return;

          const mapSize = map.getSize();
          if (!mapSize || mapSize[0] === 0 || mapSize[1] === 0) return;

          const view = map.getView();
          const currentZoom = view.getZoom();
          zoom.value = currentZoom.toFixed(1);

          // Get visible extent in geographic coordinates
          const extent = view.calculateExtent(mapSize);
          const bottomLeft = ol.proj.transform([extent[0], extent[1]], 'EPSG:3857', 'EPSG:4326');
          const topRight = ol.proj.transform([extent[2], extent[3]], 'EPSG:3857', 'EPSG:4326');
          
          const minLon = bottomLeft[0];
          const minLat = bottomLeft[1];
          const maxLon = topRight[0];
          const maxLat = topRight[1];

          // Calculate cell size to fill entire screen with fixed grid (9x9)
          const rows = gridRows.value;
          const cols = gridCols.value;
          const cellWidthDeg = (maxLon - minLon) / cols;
          const cellHeightDeg = (maxLat - minLat) / rows;

          cellSizeLon.value = cellWidthDeg;
          cellSizeLat.value = cellHeightDeg;

          const newSource = new ol.source.Vector();
          const features = [];

          // Generate exactly rows x cols grid cells
          for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
              // Calculate cell bounds
              const lat1 = minLat + row * cellHeightDeg;
              const lat2 = minLat + (row + 1) * cellHeightDeg;
              const lon1 = minLon + col * cellWidthDeg;
              const lon2 = minLon + (col + 1) * cellWidthDeg;

              // Cell center
              const centerLat = (lat1 + lat2) / 2;
              const centerLon = (lon1 + lon2) / 2;

              // Validate coordinates
              if (centerLat < -90 || centerLat > 90 || centerLon < -180 || centerLon > 180) {
                continue;
              }

              try {
                // Encode center to get Plus Code
                // Use shorter code length for readable labels at any zoom
                let codeLength = 8;
                if (currentZoom < 5) codeLength = 4;
                else if (currentZoom < 8) codeLength = 6;
                else if (currentZoom < 12) codeLength = 8;
                else if (currentZoom < 15) codeLength = 10;
                else codeLength = 11;

                const code = OpenLocationCode.encode(centerLat, centerLon, codeLength);
                const area = OpenLocationCode.decode(code);

                // Create cell polygon from calculated bounds (not from decoded area)
                // This ensures perfect 9x9 grid coverage
                const coords = [
                  ol.proj.fromLonLat([lon1, lat1]),
                  ol.proj.fromLonLat([lon2, lat1]),
                  ol.proj.fromLonLat([lon2, lat2]),
                  ol.proj.fromLonLat([lon1, lat2]),
                  ol.proj.fromLonLat([lon1, lat1])
                ];

                const cellFeature = new ol.Feature({
                  geometry: new ol.geom.Polygon([coords]),
                  type: 'cell'
                });

                // Create label at cell center
                const labelFeature = new ol.Feature({
                  geometry: new ol.geom.Point(ol.proj.fromLonLat([centerLon, centerLat])),
                  type: 'label',
                  code: code
                });

                features.push(cellFeature, labelFeature);
              } catch (error) {
                console.warn('Error at row', row, 'col', col, ':', error);
              }
            }
          }

          // Add all features
          if (features.length > 0) {
            newSource.addFeatures(features);
            vectorLayer.setSource(newSource);
            vectorSource = newSource;
          }
        };

        const handleMoveEnd = () => {
          clearTimeout(updateTimeout);
          updateTimeout = setTimeout(updateGrid, 100);
        };

        const initMap = () => {
          vectorSource = new ol.source.Vector();

          vectorLayer = new ol.layer.Vector({
            source: vectorSource,
            zIndex: 10,
            renderBuffer: 50,
            visible: gridVisible.value,
            style: (feature) => {
              const type = feature.get('type');
              if (type === 'cell') {
                return cellStyle;
              } else if (type === 'label') {
                return new ol.style.Style({
                  text: new ol.style.Text({
                    text: feature.get('code'),
                    font: 'bold 11px monospace',
                    fill: new ol.style.Fill({ color: '#000' }),
                    stroke: new ol.style.Stroke({ color: '#fff', width: 3 }),
                    overflow: true,
                    maxWidth: 200
                  })
                });
              }
            }
          });

          map = new ol.Map({
            target: 'map',
            layers: [
              new ol.layer.Tile({ source: new ol.source.OSM() }),
              vectorLayer
            ],
            view: new ol.View({
              projection: 'EPSG:3857',
              center: ol.proj.fromLonLat([77.5946, 12.9716]),
              zoom: 12,
              maxZoom: 19,
              minZoom: 2
            })
          });

          map.on('moveend', handleMoveEnd);
          map.once('rendercomplete', () => {
            updateGrid();
          });
        };

        onMounted(() => {
          initMap();
        });

        onUnmounted(() => {
          if (updateTimeout) clearTimeout(updateTimeout);
          if (map) {
            map.un('moveend', handleMoveEnd);
            map.setTarget(null);
          }
        });

        return { zoom, gridVisible, gridRows, gridCols, cellSizeLon, cellSizeLat, toggleGrid };
      }
    }).mount('#app');
  </script>
</body>
</html>
