<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Plus Code Grid Viewer</title>

  <link rel="stylesheet" href="css/lib/ol_6.5.0.css">

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      width: 100%;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    }

    #app {
      height: 100%;
      width: 100%;
      position: relative;
    }

    #map {
      height: 100%;
      width: 100%;
    }

    .info-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 12px 16px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.8;
      z-index: 1000;
      pointer-events: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .info-panel div {
      margin: 2px 0;
    }

    .info-label {
      color: #aaa;
      display: inline-block;
      width: 100px;
    }

    .info-value {
      color: #0ff;
      font-weight: bold;
    }

    .toggle-button {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.95);
      border: 2px solid #333;
      border-radius: 6px;
      padding: 10px 16px;
      font-size: 14px;
      font-weight: bold;
      color: #333;
      cursor: pointer;
      z-index: 1000;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      pointer-events: auto;
    }

    .toggle-button:hover {
      background: rgba(255, 255, 255, 1);
      transform: translateY(-1px);
    }

    .toggle-button.active {
      background: rgba(40, 167, 69, 0.95);
      color: white;
      border-color: #28a745;
    }
  </style>
</head>

<body>
  <div id="app">
    <div id="map"></div>

    <div class="info-panel" v-show="gridVisible">
      <div><span class="info-label">Zoom Level:</span><span class="info-value">{{ zoom }}</span></div>
      <div><span class="info-label">Grid Size:</span><span class="info-value">{{ gridRows }}x{{ gridCols }}</span></div>
      <div><span class="info-label">Cell Size:</span><span class="info-value">{{ cellSizeLon.toFixed(4) }}° x {{
          cellSizeLat.toFixed(4) }}°</span></div>
      <div><span class="info-label">Total Cells:</span><span class="info-value">{{ gridRows * gridCols }}</span></div>
    </div>

    <button class="toggle-button" :class="{ active: gridVisible }" @click="toggleGrid">
      {{ gridVisible ? '✓ Grid ON' : '✗ Grid OFF' }}
    </button>
  </div>

  <script src="js/lib/vue3.js"></script>
  <script src="js/lib/ol_6.5.0.js"></script>
  <script src="js/lib/openlocationcode.min.js"></script>

  <script>
    const { createApp, ref, onMounted, onUnmounted } = Vue;

    createApp({
      setup() {
        const zoom = ref(12.0);
        const gridVisible = ref(true);
        const gridRows = ref(9);
        const gridCols = ref(9);
        const cellSizeLon = ref(0);
        const cellSizeLat = ref(0);

        let map = null;
        let vectorSource = null;
        let vectorLayer = null;
        let updateTimeout = null;

        const cellStyle = new ol.style.Style({
          stroke: new ol.style.Stroke({ color: 'rgba(0, 0, 0,1)', width: 2 }),
          fill: new ol.style.Fill({ color: 'rgba(0, 0, 0, 0.0)' })
        });

        const toggleGrid = () => {
          gridVisible.value = !gridVisible.value;
          console.log("helloooo calling grid");

          if (vectorLayer) {
            vectorLayer.setVisible(gridVisible.value);
            if (gridVisible.value) updateGrid();
          }
        };

        /**
         * FIXED: Generate exactly N x N grid filling entire screen
         */
        const updateGrid = () => {
          if (!map || !vectorSource || !gridVisible.value) return;

          const mapSize = map.getSize();
          if (!mapSize || mapSize[0] === 0 || mapSize[1] === 0) return;

          const view = map.getView();
          const currentZoom = view.getZoom();
          zoom.value = currentZoom.toFixed(1);

          // Get visible extent in geographic coordinates
          const extent = view.calculateExtent(mapSize);
          const bottomLeft = ol.proj.transform([extent[0], extent[1]], 'EPSG:3857', 'EPSG:4326');
          const topRight = ol.proj.transform([extent[2], extent[3]], 'EPSG:3857', 'EPSG:4326');
          // console.log(bottomLeft,topRight)

          // let minLon = bottomLeft[0] ;
          // let minLat = bottomLeft[1];
          // let maxLon = topRight[0];
          // let maxLat = topRight[1];
          let minLon = extent[0];
          let minLat = extent[1];
          let maxLon = extent[2];
          let maxLat = extent[3];


          // Calculate cell size to fill entire screen with fixed grid (9x9)
          const rows = gridRows.value;
          const cols = gridCols.value;
          const cellWidthDeg = (maxLon - minLon) / cols;
          const cellHeightDeg = (maxLat - minLat) / rows;

          minLon = minLon - cellWidthDeg;
          maxLon = maxLon + cellWidthDeg;

          minLat = minLat - cellHeightDeg;
          maxLat = maxLat + cellHeightDeg;




          cellSizeLon.value = cellWidthDeg;
          cellSizeLat.value = cellHeightDeg;

          var generatedCodes = []



          const newSource = new ol.source.Vector();
          const features = [];

          // Generate exactly rows x cols grid cells
          for (let row = -1; row < 10 * rows + 1; row++) {
            for (let col = -1; col < 10 * cols + 1; col++) {
              // Calculate cell bounds
              const lat1 = minLat + row * cellHeightDeg / 2;
              const lat2 = minLat + (row + 1) * cellHeightDeg / 2;
              const lon1 = minLon + col * cellWidthDeg / 2;
              const lon2 = minLon + (col + 1) * cellWidthDeg / 2;

              // Cell center
              const centerLat = (lat1 + lat2) / 2;
              const centerLon = (lon1 + lon2) / 2;

              // Validate coordinates
              if (centerLat < -90 || centerLat > 90 || centerLon < -180 || centerLon > 180) {
                continue;
              }

              try {
                // Encode center to get Plus Code
                // Use shorter code length for readable labels at any zoom

                var maxCodeLength = 2

                if (cellWidthDeg < 20) {
                  maxCodeLength = 2
                }

                if (cellWidthDeg < 1) {
                  maxCodeLength = 4
                }

                if (cellWidthDeg < 0.05) {
                  maxCodeLength = 6
                }

                if (cellWidthDeg < 0.0025) {
                  maxCodeLength = 8
                }

                if (cellWidthDeg < 0.000125) {
                  maxCodeLength = 10
                }

                if (cellWidthDeg < 0.000025) {
                  maxCodeLength = 11
                }

                codeLength = maxCodeLength;



                const code = OpenLocationCode.encode(centerLat, centerLon, codeLength);

                if (generatedCodes.includes(code)) {
                  continue;
                }

                const area = OpenLocationCode.decode(code);

                // Create cell polygon from calculated bounds (not from decoded area)
                // This ensures perfect 9x9 grid coverage
                const coords = [
                  //ol.proj.fromLonLat([lon1, lat1]),
                  //ol.proj.fromLonLat([lon2, lat1]),
                  //ol.proj.fromLonLat([lon2, lat2]),
                  //ol.proj.fromLonLat([lon1, lat2]),
                  //ol.proj.fromLonLat([lon1, lat1])
                  [area.longitudeLo, area.latitudeLo],
                  [area.longitudeHi, area.latitudeLo],
                  [area.longitudeHi, area.latitudeHi],
                  [area.longitudeLo, area.latitudeHi],
                  [area.longitudeLo, area.latitudeLo]
                ].map(c => ol.proj.fromLonLat(c));





                const cellFeature = new ol.Feature({
                  geometry: new ol.geom.Polygon([coords]),
                  type: 'cell'
                });

                // // Create label at cell center
                // const labelFeature = new ol.Feature({
                //   geometry: new ol.geom.Point(ol.proj.fromLonLat([area.longitudeCenter, area.latitudeCenter]))
                // });

                console.log("Area", area);

                console.log("Label center 3857", ol.proj.fromLonLat([area.longitudeCenter, area.latitudeCenter]));

                const labelFeature = new ol.Feature({
                  geometry: new ol.geom.Point([area.longitudeCenter, area.latitudeCenter]),
                  type: "label",
                  code: code,
                  codeLength: maxCodeLength,
                });

                features.push(cellFeature, labelFeature);

                generatedCodes.push(code);
              } catch (error) {
                console.warn('Error at row', row, 'col', col, ':', error);
              }
            }
          }

          // Add all features
          if (features.length > 0) {
            newSource.addFeatures(features);
            vectorLayer.setSource(newSource);
            vectorSource = newSource;
          }
        };

        const handleMoveEnd = () => {
          clearTimeout(updateTimeout);
          updateTimeout = setTimeout(updateGrid, 100);
        };

        const initMap = () => {
          vectorSource = new ol.source.Vector();

          vectorLayer = new ol.layer.Vector({
            source: vectorSource,
            zIndex: 10,
            renderBuffer: 50,
            visible: gridVisible.value,
            style: (feature) => {
              const type = feature.get('type');
              if (type === 'cell') {
                return cellStyle;
              } else if (type === 'label') {
                let code = feature.get('code');
                code = code.replace(/0+\+*$/, '');
                let mainPart = '';
                let lastTwo = '';
                if (code.length) {
                  mainPart = code.slice(0, -2);
                  lastTwo = code.slice(-2);
                } else {
                  mainPart = code;
                }

                const ft = mainPart + (lastTwo ? '\n' + lastTwo : '');


                return new ol.style.Style({
                  text: new ol.style.Text({
                    text: ft,
                    font: 'bold 14px monospace',
                    fill: new ol.style.Fill({ color: '#000' }),
                    stroke: new ol.style.Stroke({ color: '#fff', width: 3 }),
                    overflow: true,
                    maxWidth: 200
                  })
                });
              }
            }
          });

          map = new ol.Map({
            target: 'map',
            layers: [
              new ol.layer.Tile({ source: new ol.source.OSM() }),
              vectorLayer
            ],
            view: new ol.View({
              projection: 'EPSG:4326',
              center: [77.5946, 12.9716],
              zoom: 12,
              maxZoom: 19,
              minZoom: 2
            })
          });

          map.on('moveend', handleMoveEnd);
          map.once('rendercomplete', () => {
            updateGrid();
          });
        };

        onMounted(() => {
          initMap();
        });

        onUnmounted(() => {
          if (updateTimeout) clearTimeout(updateTimeout);
          if (map) {
            map.un('moveend', handleMoveEnd);
            map.setTarget(null);
          }
        });

        return { zoom, gridVisible, gridRows, gridCols, cellSizeLon, cellSizeLat, toggleGrid };
      }
    }).mount('#app');
  </script>
</body>

</html>